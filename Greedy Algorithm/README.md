# 탐욕 알고리즘

## 1. 탐욕 알고리즘

### 1) 소개

**최적화 문제**를 해결하는 알고리즘

- 탐욕 알고리즘은 **최적해**를 구하는 데 사용되는 근시안적인 방법

**최적화 문제**: 최적(최대값 이나 최소값 같은) 값을 구하는 문제

- 해당 문제에 여러 해가 있을 수 있음
- The 최적해를 구하는 것이 아니라 an 최적해를 구하는 것

머리 속에 떠오르는 생각을 검증 없이 바로 구현할 경우 Greedy 접근이 됨

여러 경우 중 하나 선택 -> 선택 시 마다 최적이라고 생각되는 것을 선택 -> **최종적인 해답에 도달**

한번 선택 된 것은 번복하지 않음

- 대부분의 탐욕 알고리즘은 **단순하며, 제한적인 문제들에 적용**

**각 선택 시점**에서 이루어지는 **결정은 지역적으로 최적**

- 선택들을 계속 수집하여 최종적 해답을 만들었다고 하여, 최적이라는 보장은 없음

### 2) 동작 과정

#### 1. 해 선택

- 현재 상태에서 부분 문제의 최적해를 구한 뒤, **부분 해 집합**에 추가
- 하나의 선택이 이루어지면 새로운 부분 문제 발생

#### 2. 실행 가능성 검사 실시

- 새로운 부분 해 집합의 **실행가능 여부 확인**
- 문제의 **제약 조건 위반을 검사**

#### 3. 해 검사

- 새로운 부분 해 집합이 문제의 해가 되는지 확인
- 전체 문제의 해가 완성되지 않았다면 **1의 해 선택부터 다시 시작**

## 2. 동전 거스름돈 문제

### 1) 소개

손님이 지불한 금액에서 물건값을 제한 차액(거스름돈)을 지불하는 문제를 생각해보자

-> 어떻게 하면 손님에게 **거스름돈**으로 주는 지폐와 **동전의 개수를 최소한**으로 줄일 수 있을까?

### 2) 탐욕 기법 적용

#### 1. 해 선택 단계

- 가장 좋은 해 선택
- 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어드므로 **현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가**

#### 2. 실행 가능성 검사

- **거스름돈**이 손님에게 내드려야 할 **액수를 초과하는지 확인**
- 초과할 경우 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가서 현재보다 한 단계 작은 단위의 동전 추가

#### 3. 해 검사

- **거스름돈 문제의 해** = 손님에게 내드려야 하는 거스름돈의 액수
- 거스름돈을 확인해서 액수에 모자라면 다시 1로 돌아가서 거스름돈에 추가할 동전 선택

가장 큰 동전을 선택하는 탐욕 방법으로는 최적해를 구할 수 없음

탐욕 알고리즘에서 최종적인 해답을 만들었어도 최적이라는 보장은 없음

항상 최적해를 구한다는 보장을 하려면 알고리즘의 정확성을 검증하는 잡업 필요

**완전 검색 적용**

- 0원이 되도록 트리의 단말 노드까지 가는 간선의 수가 최소인 경우
- 단말 노드 까지의 간선의 수가 동전의 개수

## 3. 배낭 문제

### 1) 소개

배낭은 담을 수 있는 물건의 총 **무게(W)**가 정해져 있음 -> 창고에는 **여러 개(n개)**의 물건들이 있고 각각의 물건에는 무게와 값이 정해져 있음

**배낭이 수용할 수 있는 무게를 초과하지 않으면서 값이 총합이 되도록 어떤 물건을 선택해야 하는가?**

#### Knapsack 문제 유형

- 0-1 Knapsack : 배낭에 물건을 **통째로 담아야** 하는 문제, 물건을 **쪼갤 수 없는 경우**
- Fractional Knapsack : 물건을 **부분적으로 담는** 것이 허용되는 경우, 물건을 **쪼갤 수 있는 경우**

### 2) 완전 검색 적용

완전 검색으로 물건들의 집합 S에 대한 **모든 부분집합을 구함**

부분집합의 **총 무게가 배낭 무게 W를 초과하는 집합들은 버리고** 나머지 집합에서 총 값이 가장 큰 집합 선택

물건의 개수가 증가하면 **시간 복잡도가 지수적으로 증가**

- 원소의 수 n의 집합의 부분합의 수 2^n

### 3) 탐욕 기법 적용

**0-1 Knapsack에 대한 탐욕적 방법**

1. 값이 비싼 물건부터 채움

   -> 최적해를 구할 수 없음

2. 무게가 가벼운 물건부터 채움

   -> 최적해를 구할 수 없음

3. 무게 당 값이 높은 순서로 물건 채움

   ->  최적해를 구할 수 없음

:exclamation: **탐욕적 방법으로 최적해 구할 수 없음** 따라서 완전 검색을 해야한다

**Fractional Knapsack 문제**

물건의 일부를 잘라서 담을 수 있는 경우

- 탐욕적 방법으로 최적해를 구할 수 있음

   -> **최적해**는 이상적으로 구할 수 있는 **최대 가치**

## 4. 활동 선택 문제

### 1) 소개

#### 회의실 배정 문제

1. **사용 가능한 회의실은 하나만 존재**하고 다수의 회의가 신청된 상태

2. 회의는 시작시간과 종료 시간 존재
3. 회의 **시간이 겹치는 회의들**은 **동시에 개최 불가능**

:question: 가능한 많은 회의가 열리기 위해서 회의들을 어떻게 배정해야 하는가

### 2) 탐욕 기법 적용

**회의실 배정 문제 - 활동 선택 문제**

시작 시간과 종료 시간이 있는 n개의 활동들의 집합

- 회의 시간이 서로 겹치지 않는 **최대 개수의 활동들의 집합**을 구하는 문제

1. 종료 시간이 가장 빠른 활동 선택 (종료 시간이 빠른 순서대로 정렬 후)
2. 하위 문제의 해집합을 구해 합친다
3. 선택한 화동의 종료 시간보다 빠른 시작 시간을 가지는 활동을 모두 제거
4. 남은 활동들에 대해 앞의 과정 반복

### 3) 탐욕 기법 검증

**탐욕적 선택 속성**

- 탐욕적 선택은 최적해로 갈 수 있음 -> 탐욕적 선택은 항상 안전하다는 것을 보여야 함

  :exclamation: 종료 시간이 가장 빠른 활동을 선택하는 것은 항상 안전​ 

**최적 부분 구조**

- 최적화 문제를 정형화 -> 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남음
- **원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해**임을 증명 

### 4) 탐욕 기법과 동적 계획법의 비교

|                          탐욕 기법                           |                      동적 계획법                       |
| :----------------------------------------------------------: | :----------------------------------------------------: |
| 매 단계에서, 가장 좋아 보이는 것을 빠르게 선택한다
-> 지역 최적 선택 | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 한다 |
|       하위 문제를 풀기 전에 (탐욕적)선택이 이루어 진다       |               하위 문제가 우선 해결된다                |
|                        Top-down 방식                         |                     Bottom-up 방식                     |
|                 일반적으로, 빠르고 간결하다                  |                 좀더 느리고, 복잡하다                  |

## 5. Baby-Gin 다시보기

### 1) Baby-Gin 문제에 탐욕 기법 적용

**6개의 숫자는 6자리 정수 값으로 입려되며 카운트 리스트에 저장**

- 카운트 리스트는 0에서 9까지의 숫자의 빈도수를 저장하는 리스트

Counts 리스트의 각 원소를 체크하여 Run과 Triple 및 Baby-Gin 여부 판단

**탐욕 알고리즘 방법 적용**

- 카운트 리스트에서 Run과 Triplet 중에 가능한 것을 조사
- 조사에 사용한 데이터는 삭제
- 남은 데이터를 다시 Run과 Triplet 중에 가능한지를 조사

#### 대표적인 탐용 기법의 알고리즘들

**Prim, Kruskal, Dijkstra** : 그래프

**Huffman coding** : 문자열



