# Backtracking

## 소개

**해를 찾는 도중에 '막히면'(즉, 해가 아니면) 되돌아가서 다시 해를 찾아가는 기법**

어떤 노드의 유망성 점검 후 **유망(Promising)**하지 않다고 결정되면 해당 노드의 부모로 **되돌아가(Backtracking)** 다음 자식 노드로 감

**최적화 문제**와 **결정 문제**를 해결할 수 있다

**결정 문제**란 문제의 조건을 만족하는 해가 존재하는지 여부를 yes 또는 no로 답하는 문제

- 미로찾기
  + 미로의 입구에서 출구까지 가는 경로의 존재 유무 -> 결정 문제
  + 입구에서 출구까지 가는 최단경로 찾기 -> 최적화 문제

- n-Queen
- Map Coloring
- 부분 집합의 합
  + 원소의 합이 조건에 맞는 부분 집합 존재 -> 결정 문제
  + 원소의 개수가 최대인 부분 집합을 찾는 문제 -> 최적화 문제

#### 상태 공간 트리

1. 해를 찾기 위한 선택의 과정을 트리로 표현

2. 트리의 내부 노드는 최종 상태로 가는 중간 상태를 나타냄

3. 트리의 단말 노드는 하나의 후보해에 대한 최종 상태가 됨

4. 트리를 깊이 우선 탐색하는 방법이 백트래킹 알고리즘의 기본 형태

#### 백트래킹과 깊이 우선 탐색과의 차이

**백트래킹** : 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄인다 -> **가지치기**(pruning)로 불필요한 경로를 조기에 차단

**깊이 우선 탐색** : 모든 경로를 추적하기 떄문에 경우의 수가 너무 많은경우 **처리 불가능**

## 설계 전략

초기 상태에서 목표 상태로 가는 경로를 탐색하는 기법

1. 상태 공간 트리에 대한 깊이 우선 탐색 실시
2. 방문하는 노드가 유망한지 여부 점검
   - 노드의 유망성을 판단하는 방법은 해를 찾으려는 문제에 따라 달라짐
3. 만일 방문하는 노드가 유망하지 않을 경우, 해당 노드의 부모 노드로 돌아가서 검색 계속 진행

## 이용

### 부분 집합

**Power set** : 어떤 집합의 공집합과 자기 자신을 포함한 모든 부분집합, 원소 개수가 n일 경우 2^n

- 1 또는 0 값을 가지는 항목들로 구성된 n 개의 리스트를 만드는 방법 이용
- 리스트의 i번째 항목은 i번째의 원소가 부분집합에 포함되는지 여부를 표현

**Subset(k, n)** 

- k : 지금까지 한 선택 수, 노드의 높이
- n : 총 선택 수, 트리의 높이(단말 노드의 높이)

### 순열

- 노드 방문 시마다 저장 내용은 원소를 가리키는 인덱스 값 저장
- 같은 원소 수를 가지는 집합에 대해 부분집합과 순열의 상태 공간 트리 높이 같음
- 높이가 다른 노드들은 선택지의 수가 동일하지 않음
- 높이가 증가하면서 선택지의 수 하나씩 감소

### 동전 거스름돈 문제

최소 동전 갯수로 잔돈 거슬러 주기

동적 계획법을 적용할 수 있다

- 매번 동전의 종류에 해당하는 만큼 재귀 호출 진행
- 거스름돈 금액 < 동전 -> 선택에서 제외

